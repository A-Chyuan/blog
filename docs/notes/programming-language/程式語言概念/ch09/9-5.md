# Parameter-Passing Methods

Parameter-passing methods are the ways in which parameters are transmitted to and/or from called subprograms.

## Semantics Models of Parameter Passing

Formal parameters are characterized by one of three distinct semantics models:

- **In mode**: They can receive data from the corresponding actual parameter.
- **Out mode**: they can transmit data to the actual parameter.
- **Inout mode**: they can do both.

<div class="alert-example">

Consider a subprogram that takes two arrays of `int` values as parameters—`list1` and `list2`. The subprogram must add `list1` to `list2` and return the result as a revised version of `list2`. Furthermore, the subprogram must create a new array from the two given arrays and return it.

For this subprogram,

- `list1` should be in mode, because it is not to be changed by the subprogram.
- `list2` must be inout mode, because the subprogram needs the given value of the array and must return its new value.
- The third array should be out mode, because there is no initial value for this array and its computed value must be returned to the caller.

</div>

There are two conceptual models of how data transfers take place in parameter transmission:

- Either an actual value is copied (to the caller, to the called, or both ways) or
- an access path is transmitted. Most commonly, the access path is a simple pointer or reference.

Figure 9.1 illustrates the three semantics models of parameter passing when values are copied.

![](./img/9.1.jpg ':figure The three semantics models of parameter passing when physical moves are used.')

## Implementation Models of Parameter Passing

A variety of models have been developed by language designers to guide the implementation of the three basic parameter transmission modes.

### Pass-by-Value

When a parameter is **passed by value**, the value of the actual parameter is used to initialize the corresponding formal parameter, which then acts as a local variable in the subprogram, thus implementing *in-mode* semantics.

- Pass-by-value is normally implemented by *copy*, because accesses often are more efficient with this approach.

- It could be implemented by transmitting an access path to the value of the actual parameter in the caller, but that would *require* that the value be in a *write-protected* cell (one that can only be read). Enforcing the write protection is not always a simple matter.

    <div class="alert-example">

    For example, suppose the subprogram to which the parameter was passed passes it in turn to another subprogram.

    This is another reason to use copy transfer. As we will see in [Section 9.5.4][], C++ provides a convenient and effective method for specifying write protection on pass-by-value parameters that are transmitted by access path.

    </div>

[Section 9.5.4]: /notes/programming-language/程式語言概念/ch09/9-5?id=parameter-passing-methods-of-some-common-languages

***Advantage***

The advantage of pass-by-value is that for scalars it is fast, in both linkage cost and access time.

***Disadvantages***

The main disadvantage of the pass-by-value method if copies are used is that additional storage is required for the formal parameter, either in the called subprogram or in some area outside both the caller and the called subprogram.

In addition, the actual parameter must be copied to the storage area for the corresponding formal parameter. The storage and the copy operations can be costly if the parameter is large, such as an array with many elements.

### Pass-by-Result

**Pass-by-result** is an implementation model for *out-mode* parameters.

- When a parameter is passed by result, no value is transmitted to the subprogram.
- The corresponding formal parameter acts as a local variable, but just before control is transferred back to the caller.
- Value of formal parameter is transmitted back to the caller’s actual parameter, which obviously must be a variable. (How would the caller reference the computed result if it were a literal or an expression?)

***Advantages and Disadvantages***

The pass-by-result method has the advantages and disadvantages of pass-by-value, plus some additional disadvantages.

- If values are returned by copy (as opposed to access paths), as they typically are, pass-by-result also requires the extra storage and the copy operations that are required by pass-by-value.
- As with pass-by-value, the difficulty of implementing pass-by-result by transmitting an access path usually results in it being implemented by *copy*. In this case, the problem is in <mark>ensuring that the initial value of the actual parameter is not used in the called subprogram.</mark>

***Problem: Actual Parameter Collision***

One additional problem with the pass-by-result model is that there can be an actual parameter collision, such as the one created with the call

```
sub(p1, p1)
```

- In `sub`, assuming the two formal parameters have different names, the two can obviously be assigned different values.
- Then, whichever of the two is copied to their corresponding actual parameter last becomes the value of `p1` in the caller.

Thus, the *order* in which the actual parameters are copied determines their value.

<div class="alert-example">

Consider the following C# method, which specifies the pass-by-result method with the `out` specifier on its formal parameter.

```csharp
void fixer(out int x, out int y) {
    x = 17;
    y = 35;
}
...
f.fixer(out a, out a);
```

If, at the end of the execution of `Fixer`,

- the formal parameter `x` is assigned to its corresponding actual parameter first, then the value of the actual parameter `a` in the caller will be 35.
- If `y` is assigned first, then the value of the actual parameter `a` in the caller will be 17.

Because the order can be implementation dependent for some languages, <mark>different implementations can produce different results.</mark>

Calling a subprogram with two identical actual parameters can also lead to different kinds of problems when other parameter-passing methods are used, as discussed in [§ Pass-by-Reference][].

[§ Pass-by-Reference]: /notes/programming-language/程式語言概念/ch09/9-5?id=pass-by-reference

</div>

***Problem: Address Evaluation Timing***

Another problem that can occur with pass-by-result is that the implementor may be able to choose between two different times to evaluate the addresses of the actual parameters:

- At the time of the call.
- At the time of the return.

<div class="alert-example">

Consider the following C# method and following code:

```csharp
void doIt(out int x, int index){
    x = 17;
    index = 42;
}
...
sub = 21;
f.doIt(list[sub], sub);
```

The address of `list[sub]` changes between the beginning and end of the method.

The implementor must choose the time to bind this parameter to an address—at the time of the call or at the time of the return.

- If the address is computed on entry to the method, the value 17 will be returned to `list[21]`;
- if computed just before return, 17 will be returned to `list[42]`.

This makes programs unportable between an implementation that chooses to evaluate the addresses for out-mode parameters at the beginning of a subprogram and one that chooses to do that evaluation at the end.

An obvious way to avoid this problem is for the language designer to specify when the address to be used to return the parameter value must be computed.

</div>

### Pass-by-Value-Result (Pass-by-Copy)

**Pass-by-value-result** is an implementation model for *inout-mode* parameters
in which actual values are copied. It is in effect a combination of pass-by-value
and pass-by-result.

- The value of the actual parameter is used to initialize the corresponding formal parameter, which then acts as a local variable.
- In fact, pass-by-value-result formal parameters must have local storage associated with the called subprogram. At subprogram termination, the value of the formal parameter is transmitted back to the actual parameter.

Pass-by-value-result is sometimes called **pass-by-copy**, because the actual
parameter is copied to the formal parameter at subprogram entry and then
copied back at subprogram termination.

***Advantages***

The advantages of pass-by-value-result are relative to [§ Pass-by-Reference][].

***Disadvantages***

Pass-by-value-result shares with pass-by-value and pass-by-result the disadvantages of requiring multiple storage for parameters and time for copying values.

***Problems***

It shares with pass-by-result the problems associated with the order in which actual parameters are assigned.

### Pass-by-Reference

**Pass-by-reference** is a second implementation model for *inout-mode* parameters.

- Rather than copying data values back and forth as in pass-by-value-result,
- the pass-by-reference method transmits an *access path*, usually just an address, to the called subprogram.

This provides the access path to the cell storing the actual parameter. Thus, the called subprogram is allowed to access the actual parameter in the calling program unit. In effect, the actual parameter is shared with the called subprogram.

***Advantages***

The advantage of pass-by-reference is that the passing process itself is efficient, in terms of both time and space. Duplicate space is not required and no copying is required.

***Disadvantages***

There are, however, several disadvantages to the pass-by-reference method.

- First, access to the formal parameters will be slower than pass-by-value parameters, because of the additional level of indirect addressing that is required.
- Second, if only one-way communication to the called subprogram is required, inadvertent and erroneous changes may be made to the actual parameter. This issue is addressed below.

***Problem: Aliases***

Another problem of pass-by-reference is that aliases can be created.

This problem should be expected, because pass-by-reference makes access paths available to the called subprograms, thereby providing access to nonlocal variables.

The problem with these kinds of aliasing is the same as in other circumstances:

- It is harmful to readability and thus to reliability.
- It also makes program verification more difficult.

There are several ways pass-by-reference parameters can create aliases.

<div class="alert-example">

First, collisions can occur between actual parameters.

Consider a C++ function that has two parameters that are to be passed by reference, as in

```cpp
void fun(int &first, int &second)
```

If the call to `fun` happens to pass the same variable twice, as in

```cpp
fun(total, total)
```

then `first` and `second` in `fun` will be aliases.

</div>

<div class="alert-example">

Second, collisions between array elements can also cause aliases.

For example, suppose the function `fun` is called with two array elements that are specified with variable subscripts, as in

```cpp
fun(list[i], list[j]) // if `i` == `j`
```

If these two parameters are passed by reference and `i` happens to be equal to `j`, then `first` and `second` are again aliases.

</div>

<div class="alert-example">

Third, if two of the formal parameters of a subprogram are an element of an array and the whole array, and both are passed by reference, then a call such as

```cpp
fun1(list[i], list)
```

could result in aliasing in `fun1`, because `fun1` can access all elements of `list` through the second parameter and access a single element through its first parameter.

</div>

<div class="alert-example">

Still another way to get aliasing with pass-by-reference parameters is through collisions between formal parameters and nonlocal variables that are visible.

Consider the following C code:

```c
int *global;
void main() {
    ...
    sub(global);
    ...
}
void sub(int *param) {
    ...
}
```

Inside `sub`, `param` and `global` are aliases.

</div>

All these possible aliasing situations are eliminated if pass-by-value-result is used instead of pass-by-reference. However, in place of aliasing, other problems sometimes arise, as discussed in [§ Pass-by-Value-Result][].

[§ Pass-by-Value-Result]: /notes/programming-language/程式語言概念/ch09/9-5?id=pass-by-value-result-pass-by-copy

***Problem: Change a Passed Pointer***

Another issue with pass by reference is whether the called subprogram is allowed to change a passed pointer.

- In C, this is possible.
- In some other languages, such as Pascal and C++, formal parameters that are addresses are implicitly dereferenced in the called subprogram, which prevents such changes.

### Pass-by-Name

**Pass-by-name** is an *inout-mode* parameter transmission method that does *not* correspond to a single implementation model.

When parameters are passed by name:

- The actual parameter is textually substituted for the corresponding formal parameter in all its occurrences in the subprogram.
- Formal parameters are bound to actual values or addresses at the time of the subprogram call.

A pass-by-name formal parameter

- is bound to an access method at the time of the subprogram call,
- but the actual binding to a value or an address is *delayed* until the formal parameter is assigned or referenced.

***Closure***

- Implementing a pass-by-name parameter requires a subprogram to be passed to the called subprogram to evaluate the address or value of the formal parameter.
- The referencing environment of the passed subprogram must also be passed.

This subprogram/referencing environment is a closure (see [Section 9-12][]).

***Disadvantages***

Pass-by-name parameters are both complex to implement and inefficient. They also add significant complexity to the program, thereby lowering its readability and reliability.

***Applications of Pass-by-Name***

Because pass-by-name is not part of any widely used language, it is not discussed further here.

However, it is used at compile time by the *macros* in assembly languages and for the *generic parameters* of the generic subprograms in C++, Java 5.0, and C# 2005, as discussed in [Section 9-9][].

[Section 9-9]: /notes/programming-language/程式語言概念/ch09/9-9
[Section 9-12]: /notes/programming-language/程式語言概念/ch09/9-12

## Implementing Parameter-Passing Methods

We now address the question of how the various implementation models of
parameter passing are actually implemented.

***Run-Time Stack***

In most contemporary languages, parameter communication takes place through the run-time stack.

- The run-time stack is initialized and maintained by the run-time system, which manages the execution of programs.
- The runtime stack is used extensively for subprogram control linkage and parameter passing, as discussed in Chapter 10.

In the following discussion, we assume that the stack is used for all parameter transmission.

***Pass-by-Value Parameters***

Pass-by-value parameters have their values copied into stack locations. The stack locations then serve as storage for the corresponding formal parameters.

***Pass-by-Result Parameters***

Pass-by-result parameters are implemented as the opposite of pass-by-value.

The values assigned to the pass-by-result actual parameters are placed in the stack, where they can be retrieved by the calling program unit upon termination of the called subprogram.

***Pass-by-Value-Result Parameters***

Pass-by-value-result parameters can be implemented directly from their semantics as a combination of pass-by-value and pass-by-result.

The stack location for such a parameter is initialized by the call and is then used like a local variable in the called subprogram.

***Pass-by-Reference Parameters***

Pass-by-reference parameters are perhaps the simplest to implement. Most languages only allow variables to be passed by reference.

<div class="alert-example">

However, Fortran passes all forms of parameters by reference. In Fortran, regardless of the type of the actual parameter, only its address must be placed in the stack.

- In the case of literals, the address of the literal is put in the stack.
- In the case of an expression, the compiler must build code to evaluate the expression, which must be executed just before the transfer of control to the called subprogram. The address of the memory cell in which the code places the result of its evaluation is then put in the stack.

The Fortran compiler must prevent the called subprogram from changing parameters that are literals or expressions.

</div>

<div class="alert-example">

- Function header: `void sub (int a, int b, int c, int d)`
- Function call in `main`: `sub (w,x,y,z)` (pass `w` by value, `x` by result, `y` by value-result, `z` by reference)

Access to the formal parameters in the called subprogram is by indirect addressing from the stack location of the address.

The implementation of pass-by-value, -result, -value-result, and -reference, where the run-time stack is used, is shown in Figure 9.2.

![](./img/9.2.jpg ':figure One possible stack implementation of the common parameter-passing methods.')

Subprogram `sub` is called from `main` with the call `sub(w, x, y, z)`, where `w` is passed by value, `x` is passed by result, `y` is passed by value-result, and `z` is passed by reference.

</div>

## Parameter-Passing Methods of Some Common Languages

***C and C++***

<div class="alert-example">

- C uses pass-by-value.
- Pass-by-reference (inout mode) semantics is achieved by
using pointers as parameters.

The value of the pointer is made available to the called function and nothing is copied back.

- However, because what was passed is an access path to the data of the caller, the called function can change the caller’s data.
- But all references to pointer formal parameter must be explicitly dereferenced in the function.

</div>

<div class="alert-example">

In both C and C++, formal parameters can be typed as pointers to constants.

- The corresponding actual parameters need not be constants, for in such cases they are coerced to constants.
- This allows pointer parameters to provide the efficiency of pass-by-reference with the one-way semantics of pass-by-value.

Write protection of those parameters in the called function is implicitly specified.

</div>

<div class="alert-example">

C++ includes a special pointer type, called a **reference type**, as discussed in Chapter 6, which is often used for parameters.

Reference parameters are implicitly dereferenced in the function or method, and their semantics is pass-by-reference.

C++ also allows reference parameters to be defined to be constants. For example, we could have

```cpp
void fun(const int &p1, int p2, int &p3) { ... }
```

where

- `p1` is pass-by-reference but cannot be changed in the function `fun`
- `p2` is pass-by-value.
- `p3` is pass-by-reference.

Neither `p1` nor `p3` need be explicitly dereferenced in `fun`.

```cpp
void fun(const int &p1, int p2, int &p3) { 
    // p1 *= 10; // error: assignment of read-only reference `p1`
    p2 *= 10;
    p3 = p1 * 10; // `p1` and `p3` need not be explicitly dereferenced, e.g. `*p1`
}

int main() 
{
    int a = 2, b = 3, c = 4;
    fun(a, b, c);
    cout << "a = " << a << ", "; // 2
    cout << "b = " << b << ", "; // 3
    cout << "c = " << c << ", "; // 20
    return 0;
}
```

</div>

***Constant Parameters vs. In-Mode Parameters***

<div class="alert-example">

Constant parameters and in-mode parameters are not exactly alike. Constant parameters clearly implement in mode.

- However, in all of the common imperative languages except Ada, in-mode parameters can be assigned in the subprogram even though those changes are never reflected in the values of the corresponding actual parameters.
- In Ada, such an assignment is illegal. Constant parameters can never be assigned.

?> Constant parameters 更加嚴格。例如，in-mode parameters 可以重新賦值，儘管不會反映至相對應的 actual parameters。

</div>

***Java***

<div class="alert-example">

- As with C and C++, all Java parameters are passed by value.
- However, because objects can be accessed only through reference variables, object parameters are in effect passed by reference.

Although an object reference passed as a parameter cannot itself be changed in the called subprogram, the referenced object can be changed if a method is available to cause the change. (無法使其指向另一個物件，但可以呼叫物件的方法來改變屬性值。)

Because reference variables cannot point to scalar variables directly and Java does not have pointers, scalars cannot be passed by reference in Java (although a reference to an object that contains a scalar can). Therefore, if a scalar is passed to a Java method, it cannot be changed by that method.

</div>

***C#***

<div class="alert-example">

- The default parameter-passing method of C# is pass-by-value.
- Pass-by-reference can be specified by preceding both a formal parameter and its corresponding actual parameter with `ref`.

For example, consider the following C# skeletal method and call:

```csharp
void sumer(ref int oldSum, int newOne) { ... }
...
sumer(ref sum, newValue);
```

The first parameter to `sumer` is passed by reference; the second is passed by value.

All `ref` parameters must be assigned a value before they are passed to an actual parameter.

</div>

<div class="alert-example">

C# also supports out-mode parameters, which are pass-by-reference parameters that do not need initial values. Such parameters are specified in the formal parameter list with the `out` modifier.

</div>

***PHP***

<div class="alert-example">

- PHP’s parameter passing is similar to that of C#, except that either the actual parameter or the formal parameter can specify pass-by-reference.
- Pass-by-reference is specified by preceding one or both of the parameters with an ampersand (`&`).

</div>

***Swift***

<div class="alert-example">

- In Swift, the default parameter passing method is pass by value, and formal parameters passed this way cannot be changed in the called subprogram.
- Pass-by-reference semantics can be specified by preceding the formal parameter with the reserved word `inout`.

</div>

***Perl***

<div class="alert-example">

Perl employs a primitive means of passing parameters.

- All actual parameters are implicitly placed in a predefined array named `@_` (of all things!).
- The subprogram retrieves the actual parameter values (or addresses) from this array.

The most peculiar thing about this array is its magical nature, exposed by the fact that

- its elements are in effect aliases for the actual parameters.
- Therefore, if an element of `@_` is changed in the called subprogram, that change is reflected in the corresponding actual parameter in the call, assuming there is a corresponding actual parameter (the number of actual parameters need not be the same as the number of formal parameters) and it is a variable.

</div>

### Pass-by-Assignment

***Python and Ruby***

The parameter-passing method of Python and Ruby is called **pass-by-assignment** or **pass-by-sharing**.

?> Because all data values are objects, every variable is a reference to an object.

In pass-by-assignment, the actual parameter value is assigned to the formal parameter. Therefore, pass-by-assignment is in effect pass-by-reference, because the value of all actual parameters are references.

語義差異：

- Pass-by-reference: 修改 formal parameter 會直接影響 actual parameter，因為兩者指向同一個記憶體位置。
- Pass-by-assignment: 傳遞的是 reference。改變 formal parameter 會讓它指向新的對象，並不會影響 actual parameter。

<div class="alert-example">

For example, many objects are essentially immutable. In a pure object-oriented language, the process of changing the value of a variable with an assignment statement, as in

```
x = x + 1
```

does not change the object referenced by `x`. Rather, it takes the object referenced by `x`, increments it by 1, thereby creating a new object (with the value `x + 1`), and then changes `x` to reference the new object.

```python
def increment(x):
    x = x + 1  # creating a new object and then changes `x` to reference the new object

a = 5
increment(a)
print(a)  # 輸出 5，`a` 未受影響
```

So, when a reference to a scalar object is passed to a subprogram, the object being referenced cannot be changed in place. Because the reference is passed by value, even though the formal parameter is changed in the subprogram, that change has no effect on the actual parameter in the caller.

</div>

However, only in certain cases does this result in pass-by-reference semantics.

<div class="alert-example">

Now, suppose a reference to an array is passed as a parameter.

If the corresponding formal parameter is assigned a new array object, there is no effect on the caller.

```python
def reassign(list):
    list = [4, 5, 6]  # formal parameter 指向新的物件不影響 actual parameter

myList = [1, 2, 3]
reassign(myList)
print(myList)  # 輸出 [1, 2, 3]，myList 未改變
```

However, if the formal parameter is used to assign a value to an element of the array, as in

```python
def modify(list):
    list[0] = 99  # 修改陣列元素的值

myList = [1, 2, 3]
modify(myList)
print(myList)  # 輸出 [99, 2, 3]，myList 被改變
```

the actual parameter is affected.

So, changing the reference of the formal
parameter has no effect on the caller, but changing an element of the array
that is passed as a parameter does.

</div>

## Type Checking Parameters

It is now widely accepted that software reliability demands that the types of actual parameters be checked for consistency with the types of the corresponding formal parameters.

Without such type checking, small typographical errors can lead to program errors that may be difficult to diagnose because they are not detected by the compiler or the run-time system.

<div class="alert-example">

In the function call

```
result = sub1(1) // 1 is integer constant

sub1(float x) { ... }
```

the actual parameter is an integer constant. If the formal parameter of `sub1` is a floating-point type, no error will be detected without parameter type checking.

Although an integer 1 and a floating-point 1 have the same value, the *representations* of these two are very different. `sub1` cannot produce a correct result given an integer actual parameter value if it expects a floating-point value.

</div>

<div class="alert-example">

Early programming languages, such as Fortran 77 and the original version of C, did not require parameter type checking; most later languages require it. However, the relatively recent languages Perl, JavaScript, and PHP do not.

</div>

C and C++ require some special discussion in the matter of parameter type checking.

***In Original C and C89***

In the original C, neither the number of parameters nor their types were checked.

In C89, the formal parameters of functions can be defined in two ways. They can be defined as in the original C; that is, the names of the parameters are listed in parentheses and the type declarations for them follow, as in the following function:

```c
// original C
double sin(x)
double x;
{ ... }
```

Using this form avoids type checking, thereby allowing calls such as

```c
// original C
double value;
int count;
...
value = sin(count); // 合法，但不正確
```

to be legal, although they are never correct.

The alternative to the original C definition approach is called the **prototype** method, in which the formal parameter types are included in the list, as in

```c
// C89
double sin(double x) // prototype
{ ... }
```

If this version of `sin` is called with the same call, that is, with the following, it is also legal:

```c
// C89
int count;
...
value = sin(count); // 會被隱式轉型為 double
```

The type of the actual parameter (`int`) is checked against that of the formal parameter (`double`). Although they do not match, `int` is coercible to `double` (it is a widening coercion), so the conversion is done.

If the conversion is not possible (for example, if the actual parameter had been an array) or if the number of parameters is wrong, then a semantics error is detected. So in C89, the user chooses whether parameters are to be type checked.

***In C99 and C++***

In C99 and C++, all functions must have their formal parameters in prototype form.

<div class="alert-example">

?> However, type checking can *be avoided* for some of the parameters by replacing the last part of the parameter list with an ellipsis, as in

```c
int printf(const char* format_string, ...);
```

A call to `printf` must include at least one parameter, a pointer to a literal character string. Beyond that, anything (including nothing) is legal.

The way `printf` determines whether there are additional parameters is by the presence of format codes in the string parameter. For example, the format code for integer output is `%d`. This appears as part of the string, as in the following:

```c
printf("The sum is %d\n", sum);
```

The `%` tells the `printf` function that there is one more parameter.

</div>

***In C#***

There is one more interesting issue with actual to formal parameter coercions when primitives can be passed by reference, as in C#.

<div class="alert-example">

Suppose a call to a method passes a `float` value to a `double` formal parameter.

- If this parameter is passed by value:

    The `float` value is coerced to `double` and there is no problem.

    This particular coercion is very useful, for it allows a library to provide double versions of subprograms that can be used for both `float` and `double` values.

- However, suppose the parameter is passed by reference:

    When the value of the `double` formal parameter is returned to the `float` actual parameter in the caller, the value will overflow its location.

To avoid this problem, C# requires the type of a `ref` actual parameter to match exactly the type of its corresponding formal parameter (no coercion is allowed).

</div>

***In Python and Ruby***

In Python and Ruby, there is no type checking of parameters, because typing in these languages is a different concept.

- Objects have types, but variables do not, so formal parameters are typeless.
- This disallows the very idea of type checking parameters.

## Multidimensional Arrays as Parameters

The storage-mapping functions that are used to map the index values of references to elements of multidimensional arrays to addresses in memory were discussed at length in [Section 6-5][].

[Section 6-5]: /notes/programming-language/程式語言概念/ch06/6-5?id=multidimensional-array

In some languages, such as C and C++, when a multidimensional array is passed as a parameter to a subprogram,

- the compiler must be able to build the mapping function for that array while seeing only the text of the subprogram (not the calling subprogram).
- This is true because the subprograms can be compiled separately from the programs that call them.

Consider the problem of passing a matrix to a function in C.

- Multidimensional arrays in C are really arrays of arrays, and they are stored in row major order.
- Following is a storage-mapping function for row major order for matrices when the lower bound of all indices is 0 and the element size is 1:

    $$
    \text{address(mat[i, j]) = address(mat[0,0]) + i $\times$ number_of_columns + j}
    $$

  ?> Notice that this mapping function needs the number of columns but not the number of rows.

***In C and C++***

Therefore, in C and C++, when a matrix is passed as a parameter, the formal parameter must include the number of columns in the second pair of brackets. This is illustrated in the following skeletal C program:

```c
void fun(int matrix[][10]) { // 這樣會導致 column 固定，變得不靈活，後續說明解決辦法
    ...
}
void main() {
    int mat[5][10];
    ...
    fun(mat);
    ...
}
```

The problem with this method of passing matrices as parameters is that it does not allow a programmer to write a function that can accept matrices with different numbers of columns; a new function must be written for every matrix with a different number of columns.

This, in effect, disallows writing flexible functions that may be effectively reusable if the functions deal with multidimensional arrays.

In C and C++, there is a way around the problem because of their inclusion of pointer arithmetic.

- The matrix can be passed as a pointer.
- The actual dimensions of the matrix also can be passed as parameters.

Then, the function can evaluate the user-written storage-mapping function using pointer arithmetic each time an element of the matrix must be referenced. For example, consider the following function prototype:

```c
void fun(float *mat_ptr,
         int num_rows,
         int num_cols);
```

The following statement can be used to move the value of the variable `x` to the `[row][col]` element of the parameter matrix in `fun`:

```c
*(mat_ptr + (row * num_cols) + col) = x;
```

Although this works, it is obviously difficult to read, and because of its complexity, it is error prone. The difficulty with reading this can be alleviated by using a macro to define the storage-mapping function, such as

```c
#define mat_ptr(r, c) (*mat_ptr + ((r) * (num_cols) + (c)))
```

With this, the assignment can be written as

```c
mat_ptr(row, col) = x;
```

***In Java and C#***

Other languages use different approaches to dealing with the problem of passing multidimensional arrays.

In Java and C#, arrays are objects.

- They are all single dimensioned, but the elements can be arrays.
- Each array inherits a named constant (`length` in Java and `Length` in C#) that is set to the length of the array when the array object is created.

The formal parameter for a matrix appears with two sets of empty brackets, as in the following Java method:

```java
float sumer(float mat[][]) {
    float sum = 0.0f;
    for (int row = 0; row < mat.length; row++) {
        for (int col = 0; col < mat[row].length; col++) {
            sum += mat[row][col];
        }
    }
    return sum;
}
```

Because each array has its own length value, in a matrix the rows can have different lengths.

## Design Considerations

Two important considerations are involved in choosing parameter-passing methods:

- Efficiency.
- Whether one-way or two-way data transfer is needed.

?> Contemporary software-engineering principles dictate that access by subprogram code to data outside the subprogram should be minimized. With this goal in mind,

- In-mode parameters should be used whenever no data are to be returned through parameters to the caller.
- Out-mode parameters should be used when no data are transferred to the called subprogram but the subprogram must transmit data back to the caller.
- Inout-mode parameters should be used only when data must move in both directions between the caller and the called subprogram.

There is a practical consideration that is in conflict with this principle.

<div class="alert-example">

Sometimes it is justifiable to pass access paths for one-way parameter transmission.

When a large array is to be passed to a subprogram that does *not modify* it, a one-way method may be preferred.

- However, pass-by-value would require that the entire array be moved to a local storage area of the subprogram. This would be *costly* in both time and space.
- Because of this, large arrays are often passed by reference.

This is precisely the reason why the Ada 83 definition allowed implementors to choose between the two methods for structured parameters.

C++ constant reference parameters offer another solution.

Another alternative approach would be to allow the user to choose between the methods.

</div>

The choice of a parameter-passing method for functions is related to another design issue: functional side effects. This issue is discussed in [Section 9-10][].

[Section 9-10]: /notes/programming-language/程式語言概念/ch09/9-10

## Examples of Parameter Passing

<div class="alert-example">

***Pass-by-Value in C***

Consider the following C function:

```c
void swap1(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}
```

Suppose this function is called with

```c
swap1(c, d);
```

Recall that C uses pass-by-value. The actions of `swap1` can be described by the following pseudocode:

```algorithm
\begin{algorithm}
\caption{Actions of swap1 (Pass-by-Value)}
\begin{algorithmic}

\state a = c $\hspace{1em}$ \comment{Move first parameter value in}
\state b = d $\hspace{1em}$ \comment{Move second parameter value in}
\state temp = a
\state a = b
\state b = temp

\end{algorithmic}
\end{algorithm}
```

Although `a` ends up with `d`’s value and `b` ends up with `c`’s value, the values of `c` and `d` are *unchanged* because nothing is transmitted back to the caller.

***Pass-by-Reference in C***

We can modify the C swap function to deal with pointer parameters to achieve the effect of pass-by-reference:

```c
void swap2(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}
```

`swap2` can be called with

```c
swap2(&c, &d);
```

The actions of `swap2` can be described with the following:

```algorithm
\begin{algorithm}
\caption{Actions of swap2 (Pass-by-Reference)}
\begin{algorithmic}

\state a = \&c $\hspace{1em}$ \comment{Move first parameter address in}
\state b = \&d $\hspace{1em}$ \comment{Move second parameter address in}
\state temp = *a
\state *a = *b
\state *b = temp

\end{algorithmic}
\end{algorithm}
```

In this case, the swap operation is successful: The values of `c` and `d` are in fact interchanged.

`swap2` can be written in C++ using reference parameters as follows:

```cpp
void swap2(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

This simple swap operation is not possible in Java, because it has neither pointers nor C++’s kind of references. In Java, a reference variable can point to only an object, not a scalar value.

</div>

<div class="alert-example">

?> The semantics of pass-by-value-result is identical to those of pass-by-reference, except when aliasing is involved.

Ada uses pass-by-value-result for inout-mode scalar parameters.

To explore pass-by-value-result, consider the following function, `swap3`, which we assume uses pass-by-value-result parameters. It is written in a syntax *similar* to that of Ada.

```ada
procedure swap3(a : in out Integer, b : in out Integer)
is
    -- declarations
    temp : Integer;
begin
    temp := a;
    a := b;
    b := temp;
end swap3
```

Suppose `swap3` is called with

```ada
swap3(c, d);
```

The actions of `swap3` with this call are

```algorithm
\begin{algorithm}
\caption{Actions of swap3 (Pass-by-Value-Result)}
\begin{algorithmic}

\state addr\_c = \&c $\hspace{1em}$ \comment{Move first parameter address in}
\state addr\_d = \&d $\hspace{1em}$ \comment{Move second parameter address in}
\state a = *addr\_c $\hspace{1em}$ \comment{Move first parameter value in}
\state b = *addr\_d $\hspace{1em}$ \comment{Move second parameter value in}
\state temp = a
\state a = b
\state b = temp
\state *addr\_c = a $\hspace{1em}$ \comment{Move first parameter value out}
\state *addr\_d = b $\hspace{1em}$ \comment{Move second parameter value out}

\end{algorithmic}
\end{algorithm}
```

So once again, this swap subprogram operates correctly.

---

Next, consider the call

```ada
swap3(i, list[i]);
```

In this case, the actions are

```algorithm
\begin{algorithm}
\caption{Actions of swap3 (Pass-by-Value-Result)}
\begin{algorithmic}

\state addr\_i = \&i            $\hspace{4em}$ \comment{Move first parameter address in}
\state addr\_listi= \&list[i]   $\hspace{1em}$ \comment{Move second parameter address in}
\state a = *addr\_i             $\hspace{4em}$ \comment{Move first parameter value in}
\state b = *addr\_listi         $\hspace{2.5em}$ \comment{Move second parameter value in}
\state temp = a
\state a = b
\state b = temp
\state *addr\_i = a             $\hspace{2em}$ \comment{Move first parameter value out}
\state *addr\_listi = b         $\hspace{1em}$ \comment{Move second parameter value out}

\end{algorithmic}
\end{algorithm}
```

Again, the subprogram operates correctly,

- in this case because the addresses to which to return the values of the parameters are computed at the time of the call rather than at the time of the return.
- If the addresses of the actual parameters were computed at the time of the return, the results would be wrong.

</div>

***Pass-by-Value-Result vs. Pass-by-Reference***

Finally, we must explore what happens when *aliasing* is involved with pass-by-value-result and pass-by-reference.

Consider the following skeletal program written in *C-like* syntax:

```c
int i = 3; /* i is a global variable */
void fun(int a, int b) {
    i = b;
}
void main() {
    int list[10];
    list[i] = 5;
    fun(i, list[i]);
}
```

In `fun`

- If pass-by-reference is used, `i` and `a` are aliases.
- If pass-by-value-result is used, `i` and `a` are not aliases.

The actions of `fun`, assuming pass-by-value-result, are as follows:

```algorithm
\begin{algorithm}
\caption{Actions of fun (Pass-by-Value-Result)}
\begin{algorithmic}

\state addr\_i = \&i            $\hspace{4.5em}$ \comment{Move first parameter address in}
\state addr\_listi = \&list[i]  $\hspace{1em}$ \comment{Move second parameter address in}
\state a = *addr\_i             $\hspace{4.2em}$ \comment{Move first parameter value in}
\state b = *addr\_listi         $\hspace{2.8em}$ \comment{Move second parameter value in}
\state i = b                    $\hspace{7em}$ \comment{Sets i to 5}
\state *addr\_i = a             $\hspace{4em}$ \comment{Move first parameter value (3) out}
\state *addr\_listi = b         $\hspace{2.5em}$ \comment{Move second parameter value out}

\end{algorithmic}
\end{algorithm}
```

In this case, the assignment to the global `i` in `fun` changes its value from 3 to 5, but the copy back of the first formal parameter (the second to last line in the example) sets it back to 3.

The important observation here is that if pass-by-reference is used, the result is that the copy back is not part of the semantics, and `i` remains 5.

Also note that because the address of the second parameter is computed at the beginning of `fun`, any change to the global `i` has no effect on the address used at the end to return the value of `list[i]`.
