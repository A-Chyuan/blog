
This chapter discusses programming language support for two related parts of
many contemporary programs:

- *Exception* handling
- *Event* handling

Both exceptions and events occur at times that cannot be predetermined, and both are best handled with special language constructs and processes. Some of these constructs and processes—for example, propagation—are similar for exception handling and event handling.

# Introduction to Exception Handling

Most computer hardware systems are capable of detecting certain run-time error conditions, such as floating-point overflow.

- *Early* programming languages were designed and implemented in such a way that the user program could neither detect nor attempt to deal with such errors.

    In these languages, the occurrence of such an error simply causes the program to be terminated and control to be transferred to the operating system.

    The typical operating system reaction to a run-time error is to display a *diagnostic message*, which may be meaningful and therefore useful, or highly cryptic. After displaying the message, the program is terminated.

In the case of input and output operations, however, the situation is somewhat different.

<div class="alert-example">

A Fortran `Read` statement can intercept input errors and end-of-file conditions, both of which are detected by the input device hardware.

- In both cases, the `Read` statement can specify the label of some statement in the user program that deals with the condition.
- In the case of the end-of-file, the condition obviously is not always considered an error. In most cases, it is nothing more than a signal that one kind of processing is completed and another kind must begin.

In spite of the obvious difference between end-of-file and events that are always errors, such as a failed input process, Fortran handles both situations with the same mechanism.

Consider the following Fortran `Read` statement:

```fortran
Read(Unit=5, Fmt=1000, Err=100, End=999) Weight
```

- The `Err` clause specifies that control is to be transferred to the statement labeled `100` if an error occurs in the read operation.
- The `End` clause specifies that control is to be transferred to the statement labeled `999` if the read operation encounters the end of the file.

So, Fortran uses simple branches for both input errors and end-of-file.

</div>

There is a category of serious errors that are not detectable by hardware but can be detected by code generated by the compiler.

<div class="alert-example">

Array subscript range errors are almost never detected by hardware, but they lead to serious errors that often are not noticed until later in the program execution.

</div>

Detection of subscript range errors is sometimes required by the language design.

<div class="alert-example">

The Java language specification requires Java compilers to generate code to check the correctness of every subscript expression (they do not generate such code when it can be determined at compile time that a subscript expression cannot have an out-of-range value, for example, if the subscript is a literal).

</div>

<div class="alert-example">

In C, subscript ranges are not checked because the cost of such checking was (and still is) not believed to be worth the benefit of detecting such errors.

</div>

<div class="alert-example">

In some compilers for some languages, subscript range checking can be selected (if not turned on by default) or turned off (if it is on by default) as desired in the program or in the command that executes the compiler.

</div>

The designers of most contemporary languages have included mechanisms that allow programs to react in a standard way to certain run-time errors, as well as other program-detected unusual events. Programs may also be notified when certain events are detected by hardware or system software, so that they also can react to these events.

## Basic Concepts

***Definition***

- We consider both the errors detected by hardware, such as disk read errors, and unusual conditions, such as end-of-file (which is also detected by hardware), to be exceptions.
- We further extend the concept of an exception to include errors or unusual conditions that are software-detectable (by either a software interpreter or the user code itself).

?> Accordingly, we define **exception** to be any unusual event, erroneous or not, that is detectable by either hardware or software and that may require special processing.

***Exception Handling and Handler***

- The special processing that may be required when an exception is detected is called **exception handling**.
- This processing is done by a code unit or segment called an **exception handler**.

An exception is **raised** when its associated event occurs.

- In some C-based languages, exceptions are said to be *thrown*, rather than *raised*.

Different kinds of exceptions require different exception handlers.

- Detection of end-of-file nearly always requires some specific program action.
- But, clearly, that action would not also be appropriate for an array index range error exception.
- In some cases, the only action is the generation of an error message and an orderly termination of the program.

***Handling Exceptions Without Built-in Facilities***

The absence of separate or specific exception-handling facilities in a language does not preclude the handling of user-defined, software-detected exceptions. Such an exception detected within a program unit is often handled by the unit’s caller.

- One possible design is to send an auxiliary parameter, which is used as a status variable.

    The status variable is assigned a value in the called subprogram according to the correctness and/or normalness of the results of its computations. Immediately upon return from the called unit, the caller tests the status variable. If the value indicates that an exception has occurred, the handler, which may reside in the calling unit, can be enacted.

  <div class="alert-example">

    Many of the C standard library functions use a variant of this approach: The return values are used as error indicators.

    ```c
    #include <stdio.h>  /* printf */
    #include <stdlib.h> /* strtol */

    int main() {
        const char *str = "123abc";
        char *end; // status variable: 為 null pointer 或是指向數值之後的下一個字元（非數字）
        long value = strtol(str, &end, 10); // Convert string to long integer
        
        printf("Parsed value: %ld\n", value);

        if (*end != '\0') {
            printf("Error: Non-numeric characters found: %s\n", end);
        }
        return 0;
    }
    ```

    ```output
    Parsed value: 123
    Error: Non-numeric characters found: abc
    ```

  </div>

- Another possibility is to pass a label parameter to the subprogram.

    - Of course, this approach is possible only in languages that allow labels to be used as parameters.
    - Passing a label allows the called unit to <mark>return to a different point</mark> in the caller if an exception has occurred.
    - As in the first alternative, the handler is often a segment of the calling unit’s code.

  <div class="alert-example">

    This is a common use of label parameters in Fortran. (例如此章節的第一個例子)

  </div>

- A third possibility is to have the handler defined as a separate subprogram whose name is passed as a parameter to the called unit.

    - In this case, the handler subprogram is provided by the caller, but the called unit calls the handler when an exception is raised.
    - One problem with this approach is that one is required to send a handler subprogram with *every* call to *every* subprogram that takes a handler subprogram as a parameter, whether it is needed or not.
    - Furthermore, to deal with several different kinds of exceptions, several different handler routines would need to be passed, complicating the code.

- If it is desirable to handle an exception in the unit in which it is detected, the handler is included as a segment of code in that unit.

***Advantages of Built-in Exception Handling***

There are some definite advantages to having exception handling built into a language.

First, without exception handling, the code required to detect error conditions can considerably clutter a program.

<div class="alert-example">

Suppose a subprogram includes expressions that contain 10 references to elements of a matrix named `mat`, and any one of them could have an index out-of-range error.

Further suppose that the language does not require index range checking. Without built-in index range checking, every one of these operations may need to be preceded by code to detect a possible index range error.

Consider the following reference to an element of `mat`, which has 10 rows and 20 columns:

```java
if (row >= 0 && row < 10 && col >= 0 && col < 20)
    sum += mat[row][col];
else
    System.out.println("Index range error on mat, row = " +
                        row + " col = " + col);
```

The presence of exception handling in the language would permit the compiler to insert machine code for such checks before every array element access, greatly shortening and simplifying the source program.

</div>

---

Another advantage of language support for exception handling results from exception propagation.

?> **Exception propagation** allows an exception raised in one program unit to be handled in some other unit in its dynamic or static ancestry.

- This allows a single exception handler to be used for any number of different program units.
- This reuse can result in significant savings in development cost, program size, and program complexity.

---

A language that supports exception handling encourages its users to consider all of the events that could occur during program execution and how they can be handled. This approach is far better than not considering such possibilities and simply hoping nothing will go wrong.

Finally, there are programs in which dealing with nonerroneous but unusual situations can be simplified with exception handling, and in which program structure can become overly convoluted without it.

## Design Issues

We now explore some of the design issues for an exception-handling system when it is part of a programming language.

- Such a system might allow both predefined and user-defined exceptions and exception handlers.
- Note that predefined exceptions are implicitly raised, whereas user-defined exceptions must be explicitly raised by user code.

<div class="alert-example">

Consider the following skeletal subprogram that includes an exception-handling mechanism for an *implicitly raised exception*:

```
void example() {
    ...
    average = sum / total;
    ...
    return;

    /* Exception handlers */
    when zero_divide {
        average = 0;
        printf("Error–divisor (total) is zero\n");
    }
    ...
}
```

The exception of division by zero, which is implicitly raised, causes control to transfer to the appropriate handler, which is then executed.

</div>

---

The first design issue for exception handling is how an exception occurrence is bound to an exception handler. This issue occurs on two different levels.

- On the unit level, there is the question of how the same exception being raised at different points in a unit can be bound to different handlers within the unit.

  <div class="alert-example">

    In the example subprogram, there is a handler for a division-by-zero exception that appears to be written to deal with an occurrence of division by zero in a particular statement (the one shown).

    - But suppose the function includes several other expressions with division operators.
    - For those operators, this handler would probably not be appropriate.
    - So, <mark>it should be possible to bind the exceptions that can be raised by particular statements to particular handlers, even though the same exception can be raised by many different statements.</mark>

  </div>

- At a higher level, the binding question arises when there is no exception handler local to the unit in which the exception is raised.

    - In this case, the language designer must decide whether to propagate the exception to some other unit and, if so, where.
    - How this propagation takes place and how far it goes have an important impact on the writability of exception handlers.

  <div class="alert-example">

    - If handlers must be local, then many handlers must be written, which complicates both the writing and reading of the program.
    - On the other hand, if exceptions are propagated, a single handler might handle the same exception raised in several program units, which may require the handler to be more general than one would prefer.

  </div>

---

An issue that is related to the binding of an exception to an exception handler is whether <mark>information about the exception</mark> is made available to the handler.

---

After an exception handler executes, either control can transfer to somewhere in the program outside of the handler code or program execution can simply terminate. We term this the question of control continuation after handler execution, or simply **continuation**.

- *Termination* is obviously the simplest choice, and in many error exception conditions, the best.
- However, in other situations, particularly those associated with unusual but not erroneous events, the choice of continuing execution is best. This design is called **resumption**.

  In these cases, some conventions must be chosen to determine where execution should continue. It might be:

    - The statement that raised the exception.
    - The statement after the statement that raised the exception.
    - Or possibly some other unit.

  The choice to return to the statement that raised the exception may seem like a good one, but in the case of an error exception, it is useful only if the handler somehow is able to modify the values or operations that caused the exception to be raised. Otherwise, the exception will simply be reraised. The required modification for an error exception is often very difficult to predict. Even when possible, however, it may not be a sound practice. It allows the program to remove the symptom of a problem without removing the cause.

The two issues of binding of exceptions to handlers and continuation are illustrated in Figure 14.1.

![](./img/14.1.jpg ':figure Exception-handling control flow.')

---

When exception handling is included, a subprogram’s execution can terminate in two ways:

- when its execution is complete
- or when it encounters an exception.

In some situations, it is necessary to complete some computation regardless of how subprogram execution terminates. The ability to specify such a computation is called *finalization*. The choice of whether to support finalization is obviously a design issue for exception handling.

---

Another design issue is the following: If users are allowed to define exceptions, how are these exceptions specified?

- The usual answer is to require that they be declared in the specification parts of the program units in which they can be raised.
- The scope of a declared exception is usually the scope of the program unit that contains the declaration.

---

In the case where a language provides predefined exceptions, several other design issues follow. For example:

- Should the language run-time system provide default handlers for the built-in exceptions?
- Should the user be required to write handlers for all exceptions?
- Another question is whether predefined exceptions can be raised explicitly by the user program. This usage can be convenient if there are software-detectable situations in which the user would like to use a predefined handler.

---

Another issue is whether hardware-detectable errors can be handled by user programs. If not, all exceptions obviously are software detectable.

- A related question is whether there should be any predefined exceptions. Predefined exceptions are implicitly raised by either hardware or system software.

---

The exception-handling design issues can be summarized as follows:

- How and where are exception handlers specified, and what is their scope?
- How is an exception occurrence bound to an exception handler?
- Can information about an exception be passed to the handler?
- Where does execution continue, if at all, after an exception handler completes its execution? (This is the question of continuation or resumption.)
- Is some form of finalization provided?
- How are user-defined exceptions specified?
- If there are predefined exceptions, should there be default exception handlers for programs that do not provide their own?
- Can predefined exceptions be explicitly raised?
- Are hardware-detectable errors treated as exceptions that may be handled?
- Are there any predefined exceptions?
